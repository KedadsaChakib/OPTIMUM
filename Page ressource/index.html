<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OPTIMUM-Ressources</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <ul>
        <li><a href="../acceuil/accueil.html">ACCUEIL</a></li>
        <li><a href="../traitement/traitement.html">TRAITEMENT</a></li>
        <li><a href="../Page ressource/index.html">RESSOURCES</a></li>
      </ul>
    </header>
    <main>
      <div
      style="
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        gap: 50px 0;
      "
    >
      <p style="font-size: 30px; text-align: center">
        Ce sont les algorithmes utilisés pour développer ce site
      </p>
      <div class="cards">
        <div id="cardOne" class="card">
          <p class="gradient-text text-algo">Algorithme de</p>
          <p class="gradient-text text-algo-name">Quine McClusky</p>
        </div>
        <div id="cardTwo" class="card">
          <p class="gradient-text text-algo">Algorithme de</p>
          <p class="gradient-text text-algo-name">Petrick</p>
        </div>
      </div>
      <p style="font-size: 20px; text-align: center; margin-top: 30px">
        Pour plus d'informations, nous vous recommandons vivement de consulter
        ces algorithmes:
      </p>
      <div class="buttons">
        <a
          href="https://fr.wikipedia.org/wiki/Expansion_de_Shannon"
          id="btnTwo"
          class="btn-gradient"
          style="text-decoration: none"
          >Algorithme de Shanon</a
        >
        <a
          href="https://www.polytech.umontpellier.fr/pravo/cours/Synthese/Diaporam6-pdf/syn2_optimisation.pdf"
          id="btnOne"
          class="btn-gradient"
          style="text-decoration: none"
          >Les heuristiques</a
        >
      </div>
    </div>

    <!-- The Modal -->
    <div id="myModalOne" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <p class="modal-algo modal-algo">Algorithme de</p>
        <p class="gradient-text modal-algo-name">Quine-McCuluskey</p>
        <p>
          <br /><br />
          &nbsp &nbsp &nbsp La méthode de
          <span style="color: rgba(92, 56, 255, 1)">Quine-McCluskey</span>
          est un algorithme développé par Willard Van Orman Quine et Edward
          McCluskey qui est utilisé dans la minimisation des fonctions
          booléennes. La méthode est fonctionnellement identique à la méthode de
          Karnaugh, mais sa forme tabulaire la rend plus efficace à implémenter
          sur les machines.
          <br />
          <br />
          La méthode compris deux étapes: <br />

          &nbsp &nbsp &nbsp 1- Identifier tous impliquants premiers de la
          fonction. <br />
          &nbsp &nbsp &nbsp 2- Identifier tous les impliquants essentiels parmis
          les premiers impliquants. <br /><br />

          

          <span>MÉTHODOLOGIE:</span> <br />
          &nbsp &nbsp &nbsp La méthode contient deux phases principales: la
          recherche des impliquants premiers et la recherche des impliquants
          essentiels. Considérons la minimisation sous forme de somme de
          produits (forme normale disjonctive). <br />
          <br>
         <span>I-Recherche des premiers impliquants:</span>  <br>
         <br>
         Dans cette phase il faut suivre les étapes suivantes: <br>
          &nbsp &nbsp &nbsp 1- Convertir les mintermes de la fonction en binaire
                               et les classés en ordre croissant. <br />
          &nbsp &nbsp &nbsp 2- Créer des groupes des minterms : classer les
                              minterms dans des groupes selon le nombre des bits à "1" dans chaque
                              minterme. <br />
          &nbsp &nbsp &nbsp 3- Créer des groupement des groupes des minterms: en
          faisant des comparaisons entre les minterms des groupes adjacents ,la
          comparaison entre deux groupes adjacents se fait en repèrant les cas
          ou on a un et un seul bit qui change entre deux minterms et on le
          supprime; on continu de faire les comparaisons et les groupements des
          mintermes tant que c'est possible. <br />
          &nbsp &nbsp &nbsp 4-Aprés la fin de cette étape on aura donc les
          premiers impliquants de la fonction. <br />
          &nbsp &nbsp &nbsp On peut donc mettre ces premiers impliquants dans un
          tableau pour continuer le processus de la simplification. <br /><br />
   <br>
   <span>II-Recherche des impliquants essentiels: </span><br>
   <br>
          &nbsp &nbsp &nbsp La deuxième étape concerne les impliquants de choix
          optimal (les impliquants essentiels). Pour ce faire, on exploite la table des premiers impliquants trouvés qui est conforme à  une matrice dans laquelle les
          lignes représentent les premiers impliquants identifiés,et les
          colonnes représentent tous les mintermes de la fonction.
           Pour réduire cette table , l'algorithme utilise 3 methodes : Les impliquants essentiels , dominance des lignes et dominance des colonnes.
            <br />
           1- Pour la méthode des <span>impliquants essentiels</span>  le principe est comme suit : <br> Un premier impliquant est dit un impliquant essentiel si et seulement si il  existe un minterme qui n'est vérifié que par lui.
            Pour l'identifier alors ,il suffit de calculer pour chaque minterme le nombre de premiers impliquants qu'ils le vérifient, si c’est égal à 1 alors c’est un impliquant essentiel. </br>
           2- Pour la méthode de <span>la dominace des lignes</span>  , le principe est comme suit: <br>
            On dit qu'une ligne A domine  une ligne B  si et seulement si les premiers impliquants qui vérifient  B ,vérifient aussi A .On peut  alors supprimer A. <br>
          3- Pour la méthode de <span>la dominance des colonnes</span>  , le principe est comme suit : <br>
            On dit qu'une colonne A domine une colonne B , si et seulement si les mintermes vérifiés   par B sont aussi vérifiés par A ,on peut alors supprimer la colonne B. <br>
            <br>
            On applique ces méthodes tant que c'est possible pour obtenir à la fin la liste des impliquants essentiels qui forment la fonction simplifiée. <br>
            Si la longueur du tableau simplifié trouvé à la fin est égale à 0 , alors la simplification est términée, sinon l'algorithme de Quine McClusky s'arrete et on fait appelle à l'algorithme de PETRICK. <br>
           <br> <span>COMPLEXITÉ:</span> <br />
            &nbsp &nbsp &nbsp Bien que cet algorithme est plus pratique que la
            méthode de Karnaugh pour les fonctions à plus de 6 variables, la
            méthode de Quine-McCluskey a cependant une gamme limitée
            d'utilisation,car sa complexité est exponentielle quand le nombre de
            variables augmente. Par exemple si on a une fonction à 32 variables on
            peut trouver plus de 6,5 * 10^15 impliquants premiers. Par conséquent,
            les fonctions avec un grand nombre de variables doivent être réduites
            au minimum par d'autres méthodes , tels que le minimiseur logique
            Espresso.
            <br /><br />
        </p>
      </div>
    </div>

    <div id="myModalTwo" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <p class="modal-algo">Algorithme de</p>
        <p class="gradient-text modal-algo-name">Petrick</p>
        <br /><br />
        <p>
          &nbsp &nbsp &nbsp La méthode de
          <span style="color: rgba(92, 56, 255, 1)">Petrick</span> est une méthode de simplification des fonctions logiques , elle est similaire à celle de Quine-McClusky sauf dans l'étape de la détermination des impliquants essentiels. cet algorithme à été proposé par <span> Stanley R. Petrick </span> en 1956 et il a été optimisé par <span> Insley B. Pyne </span> et <span> Edward Joseph McCluskey</span> en 1962. <br>
          Cet algorithme est largement utilisé dans la pratique car il est facile à implémenter sur les machines et meme trés pérforment. <br>
          <br />
          <br />
          <span>METHODOLOGIE</span> <br />
           L'algorithme de petrick est fondé sur des bases purement algébriques, en effet pour extraire les impliquants essentiels il applique des traitements algebriques sur les mintermes. <br>
            Les étapes de cet algorithmes sont: <br>
            <br>
          &nbsp &nbsp &nbsp 1- On construit une P-fonction , ou on va attribuer à chaque premier impliquant un Pi qui correspond à la colonne Ci ou il se trouve. <br> <span>Par exemple:</span>  <span>A.B =P1 , C.D=P2 ...etc</span> . <br />

        <br>  &nbsp &nbsp &nbsp 2- On regroupe les Pi trouvés selon les minterms qu'ils vérifient en faisant un "ou" logique entre eux . <br><span>Par exemple: si un  minterme M10 est vérifié par les premiers impliquants A.B et C.D avec A.B=P1 et C.D=P2 , donc on écrit que M10=(P1<span>+</span>P2 ) . On fait ce travail pour tous les mintermes de la fonction.</span>   <br />

         <br> &nbsp &nbsp &nbsp 3- Aprés avoir écrit chaque minterme en fonction d'une somme des Pi , on obtient une P-fonction juste en faisant un "et" logique entre tous les mintermes car la P-fonction doit vérifier tous les mintermes de la fonction à la fois. <br />
          
         <br> &nbsp &nbsp &nbsp 4- La P-fonction va etre une fonction écrite sous la forme conjonctive (un produit de sommes). <br> <span>Par exemple: P=(P1+P2).(P3+P4).(P8+P9)....(Pi+Pj)</span>    <br />
         <br> &nbsp &nbsp &nbsp 5- Dans cette étape on doit simplifier la P-fonction , on appliquant les règles de calcule algèbrique , bien entendu la distribution pour aboutir à une P-fonction écrite sous la forme disjonctive. <br> <span>Par exemple: P=P1.P4.P6.P5+P2.P1+....+Pi.Pj.</span>  <br />
          <br>&nbsp &nbsp &nbsp 6- Aprés avoir fait la transformation en disjeonctive , on constate que chaque monome représente une solution de la fonction , donc il suffit de choisir les monomes les plus optimales pour extraire les impliquants essentiels. Le choix des monomes ce fait en fonction de nombre des premiers impliquants inclus dans chaque monome, on choisit alors les monomes avec le nombre des premiers impliquants minimal. <br> Par exemple: si P=P1.P5.P8.P9+P2.P3.P4+P7.P8 , alors on va choisir le monome P7.P8 car il contient un nombre minimal des premier impliquants. <br />
         <br> &nbsp &nbsp &nbsp 7- Aprés avoir extraire le (les) monome(s) optimal(s) , on peut donc déterminer les impliquants essentiels de notre fonction , en remplaçant chaque Pi par sa valeur. <br> <span> Par exemple: si le monome trouvé est P7.P8 avec P7=A.B et P8=D.C' , alors nos impliquants essentiels sont A.B et D.C' et la fonction simplifée est F=A.B+D.C'.</span>  <br>
          <br />
          <span>COMPLEXITE</span> <br>
          Malgré que l'algorithme de Petrick est aussi performant , or avec un nombre important des minterms , il sera limité à cause de la limitation de la distribution algebrique,qui devient énorme à gérer , donc il faut penser à une forme optimisé de cet algorithme , c'est la forme qu'on a introduit dans l'algorithme de simplification de ce site. <br>
         
         
        </p>
      </div>
    </div>
    </main>
    <script src="./script.js"></script>
  </body>
</html>
